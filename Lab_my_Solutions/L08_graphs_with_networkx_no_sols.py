# -*- coding: utf-8 -*-
"""L08_Graphs_with_NetworkX_no_sols.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11D7Q24957nmT6sqh9m0_43WmeaVtfQla

# NetworkX: Network Analysis in Python

[NetworkX](https://networkx.github.io/) is a Python package for the creation, manipulation, and study of the structure, dynamics, and functions of complex networks.

- Data structures for graphs, digraphs, and multigraphs
- Many standard graph algorithms
- Network structure and analysis measures
- Generators for classic graphs, random graphs, and synthetic networks
- Nodes can be "anything" (e.g., text, images, XML records)
- Edges can hold arbitrary data (e.g., weights, time-series)

## Let's install necessary libraries
"""

!python3 -m pip install --user networkx
#for graph plottinh
!python3 -m pip install --user  matplotlib

# need graphviz on your machine
!sudo apt-get install graphviz libgraphviz-dev graphviz-dev pkg-config
!brew install graphviz #You may need to do python3 -m pip install --install-option="--include-path=/usr/local/include/" --install-option="--library-path=/usr/local/lib/" pygraphviz
!python3 -m pip install --install-option="--include-path=/usr/local/include/" --install-option="--library-path=/usr/local/lib/" pygraphviz

import networkx as nx
print(nx.__version__)

import matplotlib.pyplot as plt
import numpy as np

"""### Some functions to plot graphs"""

from networkx.drawing.nx_agraph import graphviz_layout

def plot_graph(G):
    nx.draw(G, with_labels = True)  
    plt.show()
    
def plot_graph_with_weights(G):
    pos = nx.planar_layout(G) # pos = nx.nx_agraph.graphviz_layout(G)
    nx.draw_networkx(G,pos)
    labels = nx.get_edge_attributes(G,'weight')
    nx.draw_networkx_edge_labels(G, pos, edge_labels=labels)
    plt.show()

def plot_tree(tree):
    pos = graphviz_layout(tree, prog='dot')
    nx.draw(tree, pos, with_labels=True)
    plt.show()
    
def plot_graph_and_highlight_dijistra(G, path):
    pos = graphviz_layout(G)
    nx.draw(G, pos, with_labels = True)

    nx.draw_networkx(G, pos, nodelist=path, node_color='r', with_labels=True)
    nx.draw_networkx_nodes(G, pos, nodelist=path,node_color='r')
    path_edges = list(zip(path, path[1:]))
    nx.draw_networkx_edges(G, pos, edgelist=path_edges, edge_color='r', width=4)
    plt.show()

"""---

## Create a Graph

A graph is a __collection of nodes and edges__, *i.e.*, G = (V, E). Let us create an empty graph

Let's start by creating an empty graph
"""

G = nx.Graph()

"""Now let's __populate__ the graph. We can add one node at time using *G.add_node()* or add any iterable collections (lists, strings etc..) with *G.add_nodes_from*. 

We are now using strings as nodes's names, but nodes can be any hashable object.
"""

G.add_node('a')
my_list = ['b', 'c', 'd']
G.add_nodes_from(my_list)

"""We can __inspect the nodes__ in a graph using *G.nodes()*."""

G.nodes()

plot_graph(G)

"""Now let us __add edges__ to the graph. 

We can add one edge at time with *G.add_edge()*, specifying the nodes between whom we want the edge to stay. As for nodes, we can pass an iterable colletion to *G.add_edges_from()*.
"""

G.add_edges_from([('a', 'b'), ('a', 'c'), ('c', 'd'), ('b', 'd')])
G.edges()

"""If we add edges between nodes that does not exist, __nodes are automatically added__"""

G.add_edge("a", "e")

plot_graph(G)

"""__Remove__ nodes and/or edges using the *G.remove_node()* or the *G.remove_nodes_from()*"""

G.remove_node('e')
plot_graph(G)

"""---
## Graph properties

NewtorkX provides direct access to several __graph properties__
"""

# Number of nodes
print("Number of Nodes: ", G.order ()) # equivalent to len(G) and G.number_of_nodes()
# Number of edges
print("Number of Edges: ", G.number_of_edges())

"""Nodes can be listed with G.nodes."""

G.nodes

"""We can assign nodes some attributes, e.g., a color."""

for node in G.nodes:
    G.nodes[node]['color'] = 'white'

list(G.nodes.data())

G.nodes['a']['color']

"""We can explore the **neighbours** and the **degree** of the nodes in a graph using the facilities *G.adj* and *G.degree*."""

print(G.adj)
print(G.adj['a'])

"""Graph are __subscriptable__ objects and we can access neighbours directly with the [ ] operator."""

print(G.adj['a'])
print(G['a'])

"""We may want to add some edges properties."""

G['a']['c']['color'] = 'green'
G['a']['b']['color'] = 'black'

"""We can use *G.adj* as a dictionary and __iterate__ over it."""

for node, datadict in G.adj.items():
    # datadict is a dictionary whose keys are node neighbours and whose value, in turn, is a dictionary 
    # reporting 'property:value' of the edge between node and key
    
    print(node, datadict)

"""The degree property reports the number of edges for each node."""

print(G.degree)

G.add_edge(1,2, weight = 1.0)
G.edges().data()

"""---
## Directed Graphs

Networkx supports directed graphs.
"""

DG = nx.DiGraph()
#we add nodes and edges as a list oftriplets (or_node, dest_node, weight)
DG.add_weighted_edges_from([(1, 2, 0.5), (3, 1, 0.75), (3,2, 0.4)]) 
plot_graph_with_weights(DG)

print("Successor of node 1: Node", list(DG.successors(1))[0]) #Equivalent to DG.neighbors for directed graphs
print("Predecssor of node 1 : Node", list(DG.predecessors(1))[0])

"""We can __convert__ directed graphs to undirected one and viceversa.

"""

G = nx.to_undirected(DG)
DG = nx.to_directed(G)

"""---
## Graph Operations

Networkx supports most common graph operations. Some examples are 
<ul>
<li>Union</li>
<li>Intersection</li>
<li>Complement</li>
</ul>
"""

# Create a first graph G
G = nx.Graph()
G.add_edges_from([("a", "b"), ("b", "c"), ("c", "d")])

# Create a second graph H
H = nx.Graph()
H.add_edges_from([("e", "f"), ("f", "g"), ("g", "h") ])

# Perform the union operation
I = nx.union(G, H)
plot_graph(I)

# Now link the two connected components
I.add_edges_from([("a","e"), ("b", "g")])
plot_graph(I)

# Create a third graph
L = nx.Graph()

# To perform intersection between two graphs, they must have the same nodes
# First we copy all the nodes in I into L
L.add_nodes_from(I.nodes())

# Then we add some edge in L
L.add_edges_from([("e", "f"), ("f", "g")])

M = nx.intersection(I, L)

# Only the shared edges between I, L wil survive this operation
plot_graph(M)

"""---
## Graph Search

Several algorithm are already implemented in NetworkX, take a look [here](https://networkx.github.io/documentation/stable/reference/algorithms/index.html).

### Breadth First Search (BFS)

With Networkx it is easy to perform  graph search. Let us start with __BFS__. 

We will use a __Petersen__ graph as an example, a graph with 10 nodes and 15 edges.
"""

petersen = nx.petersen_graph()
print("Number of nodes", petersen.order())
print("Number of edges", petersen.number_of_edges())
plot_graph(petersen)

"""Networkx offers several __methods__ to perform BFS. Observe that in the method definition, the arguments in square brackets [ ]  are optional.

- bfs_edges(G, source, [reverse, depth_limit]):  returns an iterator over edges in a breadth-first-search starting at source, until depth_limit
- bfs_tree(G, source, [reverse, depth_limit]): returns an oriented tree constructed from of a breadth-first-search starting at source
- bfs_predecessors(G, source, [depth_limit]): returns an iterator of predecessors in breadth-first-search from source
- bfs_successors(G, source, [depth_limit]): returns an iterator of successors in breadth-first-search from source         
"""

# We use 0 as source node. 
edges_bfs = list(nx.bfs_edges(petersen, 0))
print("Result of BFS on edges:", edges_bfs)

# Another helpful way to understand is the tree that comes out from its execution. This can be done by using bfs_tree
tree_bfs = nx.bfs_tree(petersen, 0)

# Now we plot the resulting tree
plot_tree(tree_bfs)

"""---

### Depth First Search (DFS)

As for BFS,  Networkx offers several __methods__ to perform DFS. Observe that,as previously explained, in the method definition, the arguments in square brackets [ ]  are optional.
<ul>
  <li> dfs_edges(G, source, [reverse, depth_limit]):  returns an iterator over edges in a depth-first-search starting at source, until max_depth </li>
<li>dfs_tree(G, source, [reverse, depth_limit]): returns an oriented tree constructed from of a depth-first-search starting at source(</li>
<li>dfs_predecessors(G, source, [depth_limit]): returns an iterator of predecessors in depth-first-search from source</li>
    <li>dfs_successors(G, source, [depth_limit]): returns an iterator of successors in depth-first-search from source </li>    
    
</ul>
Let us now observe the difference between BFS and DFS
"""

# We use 0 as source node. 
edges_dfs = list(nx.dfs_edges(petersen, 0))
print("Result of dfs on edges:",edges_dfs)

tree_dfs = nx.dfs_tree(petersen, 0)

# Now we plot the resulting tree
plot_tree(tree_dfs)

"""----
### Shortest path with Dijkstra algorithm

Let us now move to the Dijkstra algorithm to find the shortest path between two points.
"""

from random import random, choice
from networkx.utils import pairwise

G = nx.Graph()

n_nodes = 15

# Generate nodes from 0 to n_nodes-1
nodes = np.arange(n_nodes)
G.add_nodes_from(nodes)

# Build a path from nodes[0] to nodes[-1] to be sure it exists
for p1, p2 in pairwise(nodes):
    G.add_edge(p1, p2, weight=np.linalg.norm(p1-p2))

    
# Add other random edges
new_edges = 25
for _ in range(new_edges):
    p1, p2 = choice(nodes), choice(nodes)
    if p1 != nodes[0] and p2!= nodes[-1]:#avoid direct link
        G.add_edge(p1, p2, weight=np.linalg.norm(p1-p2))
    
    
plot_graph(G)


# Compute Dijistra path
path =  nx.dijkstra_path(G, nodes[0], nodes[3])
print(path)
plot_graph_and_highlight_dijistra(G, path)

"""---
### Exercise: Strongly Connected Components
The goal of this exercise is to implement the following algorithm to compute the strongly connected components of a directed graph $G$. [See here](https://www.hackerearth.com/practice/algorithms/graphs/strongly-connected-components/tutorial/). 

In a directed graph a component is strongly connected if there is a directed path from any vertex to every other vertex of the component. The problem asks to is to partition the graph into maximal strongly connected components.

NetworkX provides a method to compute the strongly connected components of a graph [here](https://networkx.github.io/documentation/stable/reference/algorithms/generated/networkx.algorithms.components.strongly_connected_components.html#networkx.algorithms.components.strongly_connected_components). 

Your goal is to implement the Kosaraju's Linear time algorithm to find Strongly Connected Component. 
The algorithm is described [here](https://www.hackerearth.com/practice/algorithms/graphs/strongly-connected-components/tutorial).

It works in three steps. 

- Do a DFS on the original graph, keeping track of the DFS finish times of each node. This can be done with a stack, when some  finishes put the source vertex on the stack. This way node with highest finishing time will be on top of the stack.
- Reverse the original graph, i.e., if there is an edge $(u,v)$ in the original graph, add the edge $(v,u)$ in the reversed one.
-  Do DFS on the reversed graph, with the source vertex as the vertex on top of the stack. When DFS finishes, all nodes visited will form one Strongly Connected Component. If any more nodes remain unvisited, this means there are more Strongly Connected Component's, so pop vertices from top of the stack until a valid unvisited node is found. This will have the highest finishing time of all currently unvisited nodes.

Take a look at [DFS traversal documentation](https://networkx.github.io/documentation/stable/reference/algorithms/traversal.html#module-networkx.algorithms.traversal.depth_first_search).
Note that the finishing time of a node can be inferred from its position in the DFS tree. 



![scc.webp](data:image/webp;base64,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)
"""

edges_list = [(0, 1), (1, 2), (2, 3), (3, 0), (2, 4), (4, 5), (5, 6), (6, 4), (6, 7)]
G = nx.DiGraph()
G.add_edges_from(edges_list)
G.edges()
plot_graph(G)

list(nx.dfs_successors(G, 0))

##### FASTER SOLUTION ##### 
#about 14.2 ms

def SCC(G):
    
    def DFS(G, node, status, stack = None, scc_node = list()): #creating a function to perform the DFS
        status[node] = 'visited' #setting the node status as visited in case I perform the search
        for child_node in G.successors(node):
            if status[child_node] == 'to_visit': #if a direct successor of the node is yet to be visited
                DFS(G, child_node, status, stack, scc_node) #recursively visit it
        if stack != None: #if a stack is specified add the node to the stack (FIRST PART)
            stack.append(node)
        else: #if in the third phase add the nodes recursively found in the strongly connected component list
            scc_node.append(node)

    nodes = G.nodes
    status = {node : 'to_visit' for node in nodes} #setting the status of each node "to visit"
    stack = list() 

    ########## FIRST PART ##########
    for node in nodes:
        if status[node] == 'to_visit': 
            DFS(G, node, status, stack = stack) #add to the stack each node by its finish time (those in the deepest recursion levels will be added first)
    
    ########## SECOND PART ##########
    G_rev = G.reverse() #reverse the directions of the edges
    status = {node : 'to_visit' for node in nodes} #resetting the nod status
    scc_whole = set() #output set of Strongly connected components

    ########## THIRD PART ##########
    while len(stack) > 0: #need to empty the stack
        node = stack.pop() #pop the top of the stack at each iteration
        scc_node = list() #prepare a list to include the SCC if the curren not is yet to be visited
        if status[node] == 'to_visit':
            DFS(G_rev, node, status, scc_node = scc_node) #append the nodes of the reverse dfs to the temporary list
            scc_whole.add(tuple(scc_node)) #add the list of nodes to the set of strongly connected components

    return scc_whole
            

########## SLOWER SOLUTION WITH THE LIBRARY ##########
#about 459 ms (filtering too many times according to the visited_set and looping to the remaining set once more + listing the complete dfs of each node even if already visited the subnodes)

def SCC_slower(G):
    stack = list(nx.dfs_postorder_nodes(G)) #FIRST PART
    G_rev = G.reverse() #SECOND PART

    ########## THIRD PART ##########
    Strong_CC = set()

    status = {node : 'to_visit' for node in G_rev.nodes} #I reset the status
    visited_set = set()

    while len(stack) > 0: #need to empty the stack
        node_source = stack.pop() #pop at each iteration the last (top) node of the stack

        if status[node_source] == 'to_visit': #if the node is yet to be visited
            dfs_nodes = list(nx.dfs_postorder_nodes(G_rev, node_source)) #DFS with the top stack source node
            
            for visited in visited_set:
                dfs_nodes = list(filter(lambda x: x not in visited_set, dfs_nodes)) #remove the nodes visited in previous iterations

            Strong_CC.add(tuple(dfs_nodes)) #add these strongly connected components to the set

            for node_succession in dfs_nodes: #set all the strongly connected components as visited
                status[node_succession] = 'visited'
                visited_set.add(node_succession)
    
    return Strong_CC

SCC(G)

SCC_slower(G)

## Define some function useful for testing
import random

## generate an array of n random integers up to b
def get_random_array(n, b = 50):
    return [random.randint(0, b) for _ in range(n)]

a = set(get_random_array(1000, 1000))

len(a)

b = set([x*10000 for x in a])

len(b)

# Commented out IPython magic to ensure Python compatibility.
G = nx.DiGraph()
G.add_edges_from(zip(a, b))
# %timeit SCC(G)
# %timeit SCC_slower(G)

def test_solutions():
    import networkx as nx
    import random
    def get_random_array(n, b = 50):
        return [random.randint(0, b) for _ in range(n)]
    
    a = set(get_random_array(1000, 1000))
    b = set([x*10000 for x in a])
    G = nx.DiGraph()
    G.add_edges_from(zip(a, b))
    first_sol = %timeit -o SCC(G)
    second_sol = %timeit -o SCC_slower(G)
    print('Faster Solution:', first_sol.best)
    print('Slower Solution:', second_sol.best)
    print('Ratio:', second_sol.best/first_sol.best)

test_solutions()